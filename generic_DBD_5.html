<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
	This is an example of a sub page for each module.  It has to be replicated in each module, containing the requested contents -  artefacts, notes, reflections etc
	Ensure you give a different title to each replica and link it to the main module page accordingly.
-->
<html>
	<head>
		<title>Tasweem Beelunkhan</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="css/main.css" />
		<noscript><link rel="stylesheet" href="css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo"><span>Tasweem Beelunkhan</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<li><a href="index.html">Home</a></li>
							<li><a href="About.html">About Me</a></li>
							<li><a href="Launch Module.html">The Data Professional</a></li>
							<li><a href="Module 2.html">Numerical Analysis</a></li>
							<li><a href="Module 4.html">Deciphering Big Data</a></li>
							<li><a href="Module 3.html">Visualising Data</a></li>
							<li><a href="Module 5.html">Machine Learning PM</a></li>
							<li><a href="Module 6.html">Research Methods and Professional Practice</a></li>
							<li><a href="Project.html">Project</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h1>Artefacts</h1>
										<h3>Outcomes from the Team Exercises and activites</h3>
									</header>
									    <p>This unit consists of 3 parts:</p>
									        <ul>
									           <li>Data Normalisation</li>
 									           <li>Database Build</li>
 									           <li>Reflection piece</li>
									        </ul>
									
								          <h2> &#10021; Normalization</h2>

									
										  <p>Data analysis is a process that prepares a data model for implementation. The specific technique is called normalization.</p>

										  <p>Normalization is a data analysis technique that organizes data attributes so that they are grouped to form non-redundant, stable, flexible, and adaptive entities. (Li et al, 2009).</p>

										  <p>There are several kinds of normalization, as shown below:</p>
										  <ul>
										    <li>1NF (1st Normal Form, eliminate repeating groups): Make a separate table for each set of related attributes, and give each table a primary key.</li>
										    <li>2NF (2nd Normal Form, eliminate redundant data): If an attribute depends on only part of a multi-valued key, remove it to a separate table.</li>
										    <li>3NF (3rd Normal Form, eliminate columns not dependent on key): If attributes do not contribute to a description of the key, remove them to a separate table.</li>
										  </ul>

										  <p>1NF, 2NF, and 3NF are common requirements for data analysis.</p>


									

									 <h3 style="color: #CFA7F6;">Activity:</h3>
									
																	             
                                                                        <p>Below you will see a table with data in un-normalised form. You should normalise this data to 3rd Normal Form (3NF), showing each step of the process i.e., demonstrating 1NF, 2NF and 3NF. Use the table below: </p>
								        
									<p></p>
									        <span class="image">
							  			
								                        <img src="images/DBD_Normalisation_T0.png" alt="" />
							                        </span>
									 <p></p>

						  			<h3> &#10003;First Normal Form (1NF)</h3>
									<p>In order to reach the First Normal Form (1NF)</p>
									<ol>
								        	<li>Remove redundant groups from each table.</li>
								        	<li>For each group of related data, make a distinct table.</li>
									        <li>Use a primary key to identify each group of related data.</li>
									</ol> 
									<p>To achieve this, the NaN values are removed and then associated with  every course to each student using a composite primary key (Student Number and Course Name) as shown below.</p>
										     
										     
								                        <img src="images/DBD_Normalisation_p1.png" alt="" />
							                        </span>

									<p>Each row corresponds to a single record, and there are no recurring groups. 'Student Number' and 'Course Name' make up the primary key. The data are now in First Normal Form (1NF).</p>	
			                                                <p></p>
										     
									<h3> &#10003;Second Normal Form (2NF)</h3>

									<p>To reach the Second Normal Form (2NF)</p>

 									<ol>
 									       <li>Fulfill each First Normal Form criterion.</li>
  									       <li>Subsets of data that are applicable to multiple rows of a table should be removed and placed in separate tables.</li>
 									       <li>Use foreign keys to establish relationships between these new tables and the previous ones.</li>
  									</ol>
									<p>According to the above table, "Exam Score," "Exam Boards," and "Teacher Name" are reliant on "Course Name," whereas "Support," "Date of Birth," and "Support" are based on "Student Number." Consequently, we may divide the table into two sections: one for the information on the student and one for the information on the course.</p>
							  			
								                        <img src="images/DBD_Normalisation_p2.png" alt="" />
							                        </span>
									<p>The KeyError appears to have been triggered by trailing white spaces in the column names. The data is then spit after after eliminating these blank areas.</p>

							  			
								                        <img src="images/DBD_Normalisation_p3.png" alt="" />
							                        </span>

 									<p>Subsets of data that are applicable to several rows of a table have been removed and put in separate tables. The primary key for the "students" table is "Student Number," whereas the "courses" table contains a composite primary key made up of "Student Number" and "Course Name." The data is now in Second Normal Form (2NF).</p>
							  			
								                        <img src="images/DBD_Normalisation_p4.png" alt="" />
							                        </span>

									<h3> &#10003;Third Normal Form (3NF)</h3>

									<p>The Third Normal Form (3NF) must be attained by:</p>

									    <ol>
 									       <li>Satisfying all criteria for the second normal form.</li>
 									       <li>Columns that are not dependent on the primary key should be removed.</li>
									    </ol>

									    <p>"Exam Boards" and "Teacher Name" in our "courses" table depend on "Course Name," but not on "Student Number." As a result, "Exam Boards" and "Teacher Name" can be moved to a different table, where "Course Name" serves as the primary key.</p>

									
								                        <img src="images/DBD_Normalisation_p5.png" alt="" />
							                        </span>	

									    <p>Columns that are not reliant on the primary key have been eliminated. 'Course Name' serves as the primary key in the table 'course_details'. The data is in Third Normal Form (3NF).</p>
							  		    <p> The final normalized tables in 3NF are shown below: </p>
									
								                        <img src="images/DBD_Normalisation_T1.png" alt="" />
							                        </span>
							
								                        <img src="images/DBD_Normalisation_T2.png" alt="" />
							                        </span>
					
								                        <img src="images/DBD_Normalisation_T3.png" alt="" />
							                        </span>


									
									
									 <h3 style="color: #CFA7F6;">Advantages of Normalisation:</h3>
										  <ul>
										    <li>Data redundancy is reduced with the aid of normalization.</li>
										    <li>Improved database organization overall.</li>
										    <li>Data consistency within the database.</li>
										    <li>More adaptable database architecture.</li>
										    <li>Enforces the concept of relational integrity.</li>
										  </ul>

									 <h3 style="color: #CFA7F6;">Disadvantages of Normalisation:</h3>
										  <ul>
										    <li>Before constructing the database, you must first ascertain the demands of the user.</li>
										    <li>When the relations are normalized to higher normal forms, such as 4NF and 5NF, the performance suffers.</li>
										    <li>The process of restoring higher degree relationships to normalcy takes a long time and is challenging.</li>
										    <li>Careless deconstruction can result in a poor database design, which can cause major issues.</li>
										  </ul>
							
								
								<h2> &#10021; Database Build</h2>
									<h3 style="color: #CFA7F6;">Activity:</h3>
									
									<p>Instructions: Once you have completed the Normalisation Task (also in this unit), you should then build a relational database system, with linked tables, demonstrating your knowledge of primary and secondary keys. Test your database to ensure referential integrity.</p>
									
									<p><strong>Step 1: Import the required libraries and create a connection to the Database.</strong></p>
									<p>Here the Python standard library's sqlite3 module was used as it offers an interface to the SQLite database. Then the create_connection function is used to establish a connection to a SQLite database. A connection object is returned. And the close_connection function terminates the SQLite database connection as it is crucial to shut it down when the connection is done.</p>
								
							                        </span>
								                        <img src="images/DBD_database_build_p1.png" alt="" />
							                        </span>
									
   									<p><strong>Step 2: Create a table and insert data.</strong></p>
    									<p>To create a table, the create_table function was used which executed a SQL command. Then, to insert the data into the respective specified table, the insert_data function was used. Note: It is possible to insert numerous records at once using the cursor object's executemany method. Based on how many elements each data tuple has, the function generates insert statement placeholders dynamically.</p>

									
							                        </span>
								                        <img src="images/DBD_database_build_p2.png" alt="" />
							                        </span>
									 <p></p>
							                <p><strong>Step 3: Test referential integrity.</strong></p>
  							                <p>Test for referential integrity by attempting to put a row into the "courses" table with a "Student_Number" or "Course_Name" that doesn't already exist in the "students" or "course_details" tables, respectively. e.g (9999, 'Nonexistent Course', 80). Result: The fact that there was no IntegrityError suggests that the foreign key constraints are functioning properly, and the database is maintaining referential integrity. The database is correctly preventing from inserting invalid data that would violate the relationships between the tables.</p>

									        </span>
								                        <img src="images/DBD_database_build_p3.png" alt="" />
							                        </span>
                                                                       <p></p>
							               <p><strong>Step 4: Definition and execution of the main Function.</strong></p>
								       <p>The main function creates the connection, creates the tables, populates the tables with data, checks referential integrity, and then closes the connection to complete the database setup. When creating the tables, the columns need to be properly defined. For example, Student_Number integer primary key where this line denotes that the "Student_Number" column, which contains integer values, is created by this line. The primary key keyword denotes that this column serves as the table's primary key.</p>
								       <p>Below is an Entity-Relationship Diagram of the database:</p>
									
							                        </span>
								                        <img src="images/DBD_database_build_p6.png" alt="" />
							                        </span>
									 <p></p>
								       <p>Also, the main function specifies the data to insert into the tables as well as the SQL statements for establishing the tables. When the script is executed, the final line, if __name__ == '__main__': main(), ensures that the main function is called.</p>

										</span>
								                        <img src="images/DBD_database_build_p4.png" alt="" />
							                        </span>
								       <p></p>
								       <p>When the script is executed, the final line, if __name__ == '__main__': main(), ensures that the main function is called. </p>
									
							                        </span>
								                        <img src="images/DBD_database_build_p5.png" alt="" />
							                        </span>

									 <p></p>
									<h3>References:</h3>
										  <ul>
										    <li>DBMS normalization: 1NF, 2NF, 3NF and BCNF with examples - javatpoint (no date) www.javatpoint.com. Available at: <a href="https://www.javatpoint.com/dbms-normalization">https://www.javatpoint.com/dbms-normalization</a> (Accessed: 21 July 2023).</li>
										    <li>Li, Q. and Chen, Y.-L. (2009) ‘Entity-relationship diagram’, Modeling and Analysis of Enterprise and Information Systems, pp. 125–139. doi:10.1007/978-3-540-89556-5_6.</li>
										    <li>‘Introducing relational theory’ (no date) Beginning Relational Data Modeling, pp. 27–56. doi:10.1007/978-1-4302-0015-4_2.</li>
										  </ul>
                                                                 


                                                                <h2> &#10021; Reflective Piece</h2>

								
                                                                 <p>In the hospitality industry, data normalization and database design are essential for data integrity, consistency, and efficiency. These principles learned throughout this unit to reduce data redundancy and prevent anomalies, is crucial in systems like bookings where accuracy is paramount. A well-designed database facilitates efficient data querying, necessary for large databases like customer databases or hotel inventories. </p>
                                                                 <p>Normalization ensures data consistency which is important to properly maintain customer experiences. A properly normalized and designed database is more scalable, adapting to changes like new hotels or services. </p>
                                                                 <p>It also facilitates data analysis and insights generation, enabling the identification of trends, demand prediction, or efficacy of promotions. More specifically, as a person who uses Power BI daily, normalized databases simplify the data model, making it easier to connect various tables and create complex relationships in Power BI. This leads to more meaningful, detailed, and comprehensive visualizations. Also, efficient querying from a well-structured database can lead to faster data refresh times in Power BI, which is critical when dealing with real-time or near-real-time data. </p>  
                                                                 <p>Lastly, it enhances data security by allowing restrictions on tables with sensitive data. In summary, understanding normalization and database design helps a data scientist in the hospitality industry improve data management, efficiency, security, and business insights.</p>
	
									
									
								</div>
							</section>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="icons">
								<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
								<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
							</ul>
							<ul class="copyright">
								<li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="js/jquery.min.js"></script>
			<script src="js/jquery.scrolly.min.js"></script>
			<script src="js/jquery.scrollex.min.js"></script>
			<script src="js/browser.min.js"></script>
			<script src="js/breakpoints.min.js"></script>
			<script src="js/util.js"></script>
			<script src="js/main.js"></script>

	</body>
</html>
